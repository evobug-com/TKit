// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'category_mapping_providers.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(categoryMappingRepository)
const categoryMappingRepositoryProvider = CategoryMappingRepositoryProvider._();

final class CategoryMappingRepositoryProvider
    extends
        $FunctionalProvider<
          ICategoryMappingRepository,
          ICategoryMappingRepository,
          ICategoryMappingRepository
        >
    with $Provider<ICategoryMappingRepository> {
  const CategoryMappingRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'categoryMappingRepositoryProvider',
        isAutoDispose: false,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$categoryMappingRepositoryHash();

  @$internal
  @override
  $ProviderElement<ICategoryMappingRepository> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  ICategoryMappingRepository create(Ref ref) {
    return categoryMappingRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(ICategoryMappingRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<ICategoryMappingRepository>(value),
    );
  }
}

String _$categoryMappingRepositoryHash() =>
    r'e1032234dcd3afd1d5833a5e9ae80a94166b8ec2';

@ProviderFor(getAllMappingsUseCase)
const getAllMappingsUseCaseProvider = GetAllMappingsUseCaseProvider._();

final class GetAllMappingsUseCaseProvider
    extends
        $FunctionalProvider<
          GetAllMappingsUseCase,
          GetAllMappingsUseCase,
          GetAllMappingsUseCase
        >
    with $Provider<GetAllMappingsUseCase> {
  const GetAllMappingsUseCaseProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'getAllMappingsUseCaseProvider',
        isAutoDispose: false,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$getAllMappingsUseCaseHash();

  @$internal
  @override
  $ProviderElement<GetAllMappingsUseCase> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  GetAllMappingsUseCase create(Ref ref) {
    return getAllMappingsUseCase(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(GetAllMappingsUseCase value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<GetAllMappingsUseCase>(value),
    );
  }
}

String _$getAllMappingsUseCaseHash() =>
    r'88007e514ef397cf519d9bdb3531b474d6f5fc19';

@ProviderFor(findMappingUseCase)
const findMappingUseCaseProvider = FindMappingUseCaseProvider._();

final class FindMappingUseCaseProvider
    extends
        $FunctionalProvider<
          FindMappingUseCase,
          FindMappingUseCase,
          FindMappingUseCase
        >
    with $Provider<FindMappingUseCase> {
  const FindMappingUseCaseProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'findMappingUseCaseProvider',
        isAutoDispose: false,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$findMappingUseCaseHash();

  @$internal
  @override
  $ProviderElement<FindMappingUseCase> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  FindMappingUseCase create(Ref ref) {
    return findMappingUseCase(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(FindMappingUseCase value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<FindMappingUseCase>(value),
    );
  }
}

String _$findMappingUseCaseHash() =>
    r'dd4343a372436728802659d81a6b9758ac19ddf5';

@ProviderFor(saveMappingUseCase)
const saveMappingUseCaseProvider = SaveMappingUseCaseProvider._();

final class SaveMappingUseCaseProvider
    extends
        $FunctionalProvider<
          SaveMappingUseCase,
          SaveMappingUseCase,
          SaveMappingUseCase
        >
    with $Provider<SaveMappingUseCase> {
  const SaveMappingUseCaseProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'saveMappingUseCaseProvider',
        isAutoDispose: false,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$saveMappingUseCaseHash();

  @$internal
  @override
  $ProviderElement<SaveMappingUseCase> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  SaveMappingUseCase create(Ref ref) {
    return saveMappingUseCase(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(SaveMappingUseCase value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<SaveMappingUseCase>(value),
    );
  }
}

String _$saveMappingUseCaseHash() =>
    r'e93d4816b41f9ee1323337ecdfade1b5bd0d5b22';

@ProviderFor(deleteMappingUseCase)
const deleteMappingUseCaseProvider = DeleteMappingUseCaseProvider._();

final class DeleteMappingUseCaseProvider
    extends
        $FunctionalProvider<
          DeleteMappingUseCase,
          DeleteMappingUseCase,
          DeleteMappingUseCase
        >
    with $Provider<DeleteMappingUseCase> {
  const DeleteMappingUseCaseProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'deleteMappingUseCaseProvider',
        isAutoDispose: false,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$deleteMappingUseCaseHash();

  @$internal
  @override
  $ProviderElement<DeleteMappingUseCase> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  DeleteMappingUseCase create(Ref ref) {
    return deleteMappingUseCase(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(DeleteMappingUseCase value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<DeleteMappingUseCase>(value),
    );
  }
}

String _$deleteMappingUseCaseHash() =>
    r'3e7e6d0669e694a6a989868d5f75dbd97bab3f2d';

@ProviderFor(CategoryMappings)
const categoryMappingsProvider = CategoryMappingsProvider._();

final class CategoryMappingsProvider
    extends $NotifierProvider<CategoryMappings, CategoryMappingState> {
  const CategoryMappingsProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'categoryMappingsProvider',
        isAutoDispose: false,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$categoryMappingsHash();

  @$internal
  @override
  CategoryMappings create() => CategoryMappings();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(CategoryMappingState value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<CategoryMappingState>(value),
    );
  }
}

String _$categoryMappingsHash() => r'cf8f497de10ddca4abc7e601026ac2a24132a3b8';

abstract class _$CategoryMappings extends $Notifier<CategoryMappingState> {
  CategoryMappingState build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<CategoryMappingState, CategoryMappingState>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<CategoryMappingState, CategoryMappingState>,
              CategoryMappingState,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
